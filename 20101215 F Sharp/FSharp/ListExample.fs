module ListExample

open System

printfn "Basic list operations ----------------------------------------------------------------------"

// empty list
let emptyList = []

// single item pushed onto the front of an empty list with the "cons" operator
let singleItemList = "item" :: []

// multi-item list declared inline
let multiItemList = ["item1"; "item2"; "item3"]

// concatenate two lists with the append operator
let compoundList = singleItemList @ multiItemList

// declare and concatenate two lists inline
let compoundList2 = "item" :: [] @ ["item1"; "item2"; "item3"]

printfn "%A" emptyList          //[]
printfn "%A" singleItemList     //["item"]
printfn "%A" multiItemList      //["item1"; "item2"; "item3"]
printfn "%A" compoundList       //["item", "item1"; "item2"; "item3"]
printfn "%A" compoundList2      //["item", "item1"; "item2"; "item3"]

printfn ""
printfn "List iteration operations ------------------------------------------------------------------"

let exampleList = ["one"; "two"; "three"]
let exampleList2 = ["a"; "b"; "c"]

//iterating over lists with an anonymous function
List.iter (fun x -> printfn "List.iter: element is %s" x) exampleList

//iterate over lists with an anonymous function, using index and element
List.iteri (fun i x -> printfn "List.iteri: element %s at index %d" x i) exampleList

//iterate over two lists with an anonymous function
List.iter2 (fun x y -> printfn "List.iter2: list 1 [%s] list 2 [%s]" x y) exampleList exampleList2

//iterate over two lists with an anonymous function, using index and element
List.iteri2 (fun i x y -> printfn "List.iteri2: list 1 [%s] list 2 [%s] index [%d]" x y i) exampleList exampleList2

printfn""
printfn "List mapping -----------------------------------------------------------------------------"

let mapList1 = ["map1a"; "map1b"; "map1c"]
printfn "mapList1: %A" mapList1

//map an anonymous function to each element in the list
let mapList1Upper = List.map (fun x -> (string x).ToUpper()) mapList1
printfn "mapList1Upper: %A" mapList1Upper

//collect and join lists generated by an anonymous function applied to each element in the list
let mapList1Collect = List.collect (fun x -> Array.toList((string x).ToCharArray())) mapList1
printfn "mapList1Collect: %A" mapList1Collect

//map an anonymous function to each element in the list, using index
let mapList1WithIndex = List.mapi (fun i x -> i.ToString() + "-" + x) mapList1
printfn "mapList1WithIndex: %A" mapList1WithIndex

//map an anymous function to each element in two lists, using index
let mapList2 = [10; 20; 30]
let mapList1and2 = List.mapi2 (fun i x y -> sprintf "index: %d - list1: [%s] list2: [%d]" i x y) mapList1 mapList2
printfn "mapList1and2: %A" mapList1and2

//map an anonymous function to elements in the list that match the criteria
let filteredList2 = List.filter (fun x -> x % 3 = 0) mapList2
printfn "filteredList2: %A" filteredList2

printfn ""
printfn "List properties --------------------------------------------------------------------------"

let propertyList = ["prop1"; "prop2"; "prop3"]
printfn "propertyList.IsEmpty: %b" (propertyList.IsEmpty)
printfn "propertyList.Length: %d" (propertyList.Length)
printfn "propertyList.Head: %s" (propertyList.Head)
printfn "propertyList.Tail.Head: %s" (propertyList.Tail.Head)
printfn "propertyList.Item(1): %s" (propertyList.Item(1))


printfn ""
printfn "List matching ------------------------------------------------------------------------------"

let theList = ["backwards."; "is"; "sentence"; "This"]

let rec invert backwardsList = 
    match backwardsList with
    | head :: tail -> (invert tail) + " " + head
    | [] -> ""

printfn "%A" (invert theList) // "This sentence is backwards."

Console.ReadKey(true) |> ignore
